const chalk = require('chalk')
const os = require('os')
const toolbox = require('gluegun/toolbox')

const {
  getSubgraphBasename,
  validateSubgraphName,
} = require('../command-helpers/subgraph')
const { fixParameters } = require('../command-helpers/gluegun')
const { runInit, initSubgraphFromContract, initSubgraphFromExample, loadAbiFromBlockScout, loadAbiFromEtherscan, loadAbiFromFile} = require('../lib/init')

const HELP = `
${chalk.bold('graph init')} [options] [subgraph-name] [directory]

${chalk.dim('Options:')}

      --allow-simple-name       Use a subgraph name without a prefix (default: false)
  -h, --help                    Show usage information

${chalk.dim('Choose mode with one of:')}

      --from-contract <address> Creates a scaffold based on an existing contracts. Accepts comma separated contract addresses.
      --from-example            Creates a scaffold based on an example subgraph

${chalk.dim('Options for --from-contract:')}

      --abi <path>              Path to the contract ABI (default: download from Etherscan). Accepts comma separated ABI file path.
      --network <mainnet|kovan|rinkeby|ropsten|goerli|poa-core>
                                Selects the network the contract is deployed to
      --index-events            Index contract events as entities
      --contract-name           Name of the contract (default: Contract). Accepts comma separated contract names.
      --etherscan-apikey        Etherscan API key. Default etherscan rate limit is 1 transaction per 3 sec. API key will increase ratelimt. 
`

const processInitForm = async (
  toolbox,
  {abis, addresses, allowSimpleName, directory, fromExample, network, subgraphName, contractNames, etherscanApikey},
) => {
  let networkChoices = ['mainnet', 'kovan', 'rinkeby', 'ropsten', 'goerli', 'poa-core']
  let addressPattern = /^(0x)?[0-9a-fA-F]{40}$/

  let abiFromEtherscan = undefined
  let abiFromFile = undefined

  let questions = [
    {
      type: 'input',
      name: 'subgraphName',
      message: 'Subgraph name',
      initial: subgraphName,
      validate: name => {
        try {
          validateSubgraphName(name, { allowSimpleName })
          return true
        } catch (e) {
          return `${e.message}

  Examples:
  
    $ graph init ${os.userInfo().username}/${name}
    $ graph init ${name} --allow-simple-name`
        }
      },
      result: value => {
        subgraphName = value
        return value
      },
    },
    {
      type: 'input',
      name: 'directory',
      message: 'Directory to create the subgraph in',
      initial: () => directory || getSubgraphBasename(subgraphName),
      validate: value =>
        toolbox.filesystem.exists(value || directory || getSubgraphBasename(subgraphName))
          ? 'Directory already exists'
          : true,
    },
    {
      type: 'select',
      name: 'network',
      message: 'Ethereum network',
      choices: networkChoices,
      skip: fromExample !== undefined,
      initial: network || 'mainnet',
      result: value => {
        network = value
        return value
      },
    },
    {
      type: 'input',
      name: 'addresses',
      message: 'Comma separated Contract addresses',
      skip: fromExample !== undefined,
      initial: addresses,
      validate: async value => {
        if (fromExample !== undefined) {
          return true
        }

        const contractList = value.split(",").map(v => v.trim());

        // Validate whether the address is valid
        for(let p=0; p<contractList.length; p++) {
          if (!addressPattern.test(contractList[p])) {
            return `Contract address "${contractList[p]}" is invalid.
    Must be 40 hexadecimal characters, with an optional '0x' prefix.`
          } 
        }
        return true
      },
      result: async value => {
        if (fromExample !== undefined) {
          return value
        }
        value = value.split(",").map(v => v.trim());
        
        // Try loading the ABI from Etherscan, if none was provided
        if (!abis) {
          try {
            if (network === 'poa-core') {
              abiFromBlockScout = await Promise.all(value.map((c) => loadAbiFromBlockScout(network, c)))
            } else {
              abiFromEtherscan = await Promise.all(value.map((c) => loadAbiFromEtherscan(network, c, etherscanApikey)))
            }
          } catch (e) {}
        }
        return value
      },
    },
    {
      type: 'input',
      name: 'abis',
      message: 'Comma separated ABI file (path),',
      initial: abis,
      skip: () => fromExample !== undefined || abiFromEtherscan !== undefined,
      validate: async value => {
        if (fromExample || abiFromEtherscan) {
          return true
        }

        try {
          abiFromFile = await Promise.all(value.split(",").map((abi) => loadAbiFromFile(abi.trim())));
          //abiFromFile = await loadAbiFromFile(value)
          return true
        } catch (e) {
          return e.message
        }
      },
    },
    {
      type: 'input',
      name: 'contractNames',
      message: 'Comma separated contract names',
      initial: contractNames || 'Contract',
      skip: () => fromExample !== undefined,
      validate: value => value && value.length > 0,
      result: value => {


        contractNames = value.split(",").map((v) => v.trim());
        return contractNames;
      }
    },
  ]

  try {
    let answers = await toolbox.prompt.ask(questions)
    return { ...answers, abis: abiFromEtherscan || abiFromFile }
  } catch (e) {
    return undefined
  }
}



module.exports = {
  description: 'Creates a new subgraph with basic scaffolding',
  options: {
    boolean: ['from-example'],
  },
  run: async toolbox => {
    // Obtain tools
    let { print, system } = toolbox

    // Read CLI parameters
    let {
      abi,
      allowSimpleName,
      fromContract,
      contractName,
      fromExample,
      h,
      help,
      indexEvents,
      network,
      etherscanApikey
    } = toolbox.parameters.options

    let abis = abi && abi.split(",").map((a) => a.trim());
    let contractNames = contractName && contractName.split(",").map((c) => {
      const temp = c.trim();
      return temp.replace(/[^a-zA-Z0-9]/g, '');
    });
    
    let fromContracts = fromContract && fromContract.split(",").map((fc) => fc.trim())
    
    // Show help text if requested
    if (help || h) {
      print.info(HELP)
      return
    }
  
    let subgraphName, directory
    try {
      ;[subgraphName, directory] = fixParameters(toolbox.parameters, {
        fromExample,
        allowSimpleName,
        help,
        h,
        indexEvents,
      })
    } catch (e) {
      print.error(e.message)
      process.exitCode = 1
      return
    }

    fromContracts = fromContracts.map((fca, index) => {
      return {
        contractAddress: fca,
        contractAbi : abis[index],
        contractName: contractNames[index],
        templateContracts: []
      }
    })
    let initRes = await runInit({subgraphName, directory, network, fromContracts, etherscanApikey, indexEvents, allowSimpleName, fromExample});
    
    if(initRes !== `Process Init Form`) {
      return initRes
    }

    // Otherwise, take the user through the interactive form
    let inputs = await processInitForm(toolbox, {
      abis,
      allowSimpleName,
      directory,
      addresses: fromContracts,
      fromExample,
      network,
      subgraphName,
      contractNames,
      etherscanApikey
    })

    // Exit immediately when the form is cancelled
    if (inputs === undefined) {
      process.exit(1)
      return
    }

    print.info('———')

    // Detect Yarn and/or NPM
    let yarn = await toolbox.system.which('yarn')
    let npm = await toolbox.system.which('npm')
    if (!yarn && !npm) {
      toolbox.print.error(
        `Neither Yarn nor NPM were found on your system. Please install one of them.`,
      )
      process.exitCode = 1
      return 
    }
    
    let commands = {
      install: yarn ? 'yarn' : 'npm install',
      codegen: yarn ? 'yarn codegen' : 'npm run codegen',
      deploy: yarn ? 'yarn deploy' : 'npm run deploy',
    }

    if (fromExample) {
      await initSubgraphFromExample(
        toolbox,
        {
          subgraphName: inputs.subgraphName,
          directory: inputs.directory,
        },
        { commands },
      )
    } else {
      fromContracts = input.addresses.map((fca, index) => {
        return {
          contractAddress: fca,
          contractAbi : input.abis[index],
          contractName: input.contractNames[index],
          templateContracts: []
        }
      })
      await initSubgraphFromContract(
        toolbox,
        {
          allowSimpleName,
          subgraphName: inputs.subgraphName,
          directory: inputs.directory,
          network: inputs.network,
          fromContracts,
          indexEvents,
          etherscanApikey,
          allowSimpleName,
        },
        { commands },
      )
    }
  }
}


